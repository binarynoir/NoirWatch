#!/usr/bin/env bash

# App Name: NoirWatch
# Description: Monitor specified websites for changes and send notifications.
# Author: John Smith III
# License: MIT License

# App version and name
readonly APP_NAME="NoirWatch"
readonly VERSION=1.3.2
readonly LAST_UPDATED="2024-12-30"

# TODO:
#  - Add more notification methods (email, slack, discord, etc.)

# ==============================
# Application Specific Variables
# ==============================

# Initialize CLI URLS as an empty array
CLI_URLS=()

# Default threshold percentage (higher is less sensitive)
THRESHOLD=0

# Application specific dependencies
DEPENDENCIES=("shasum" "timeout" "xmllint")

# ==============================
# Base Application Variables
# ==============================

# Default configuration file location (full default path added during initialization)
CONFIG_FILE_NAME="$(basename "$0").json"
SKIP_CONFIG_KEYS=("PID_FILE")

# Master directory to store all cache files (full default path added during initialization)
CACHE_DIR="$(basename "$0")_cache"

# Default log file location (full default path added during initialization)
LOG_FILE_NAME="$(basename "$0").log"
INIT_FORCE=false

# Lock file (full default path added during initialization)
PID_FILE_NAME="$(basename "$0").pid"

# Service mode flag
IS_SERVICE=false

# Default check interval (in seconds)
CHECK_INTERVAL="60s"

# Default timeout interval (in seconds)
TIMEOUT="5s"

# Default check repeat (0=infinite)
REPEAT=0

# Pushover notification options
PUSHOVER_NOTIFICATION=false
PUSHOVER_USER_KEY=
PUSHOVER_API_TOKEN=

# Native desktop notification options
DESKTOP_NOTIFICATION=false

# Log levels
# Define log levels directly as an associative array
readonly declare -A LOG_LEVELS_MAP=(
    ["FATAL"]=0
    ["ERROR"]=1
    ["WARN"]=2
    ["INFO"]=3
    ["DEBUG"]=4
)
LOG_LEVEL="INFO"
VERBOSE=false

# System host name
SYSTEM_NAME=""

# ANSI color codes
readonly RED='\033[0;31m'
readonly RED_BG='\033[41m'
readonly GREEN='\033[0;32m'
readonly GREEN_BG='\033[42m'
readonly YELLOW='\033[1;33m'
readonly YELLOW_BG='\033[43m'
readonly ORANGE='\033[0;33m'
readonly ORANGE_BG='\033[43m'
readonly NC='\033[0m' # No Color

# ==============================
# Utility Functions
# ==============================

# Function: Show version information
show_version() {
    printf "%s version: %s\n" "$APP_NAME" "$VERSION"
    printf "Last updated: %s\n" "$LAST_UPDATED"
}

# Function: Check for required command-line utilities
check_dependencies() {
    DEPENDENCIES+=("cat" "curl" "hostname" "jq" "sed")

    case "$OSTYPE" in
    linux*)
        DEPENDENCIES+=("realpath")
        ;;
    darwin*)
        DEPENDENCIES+=("grealpath")
        ;;
    cygwin* | msys* | win32*)
        DEPENDENCIES+=("powershell")
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    for cmd in "${DEPENDENCIES[@]}"; do
        # Debug log for each dependency being checked
        log_message "DEBUG" "Checking if dependency '$cmd' is installed..." "$LINENO"

        if ! command -v "$cmd" &>/dev/null; then
            log_message "FATAL" "Error: $cmd is not installed. Please install it and try again." "$LINENO"
            exit 1
        else
            log_message "DEBUG" "Success: $cmd is installed!" "$LINENO"
        fi
    done

    # Optional success debug log
    log_message "DEBUG" "All dependencies are installed." "$LINENO"
}

# Function: Get system host name
get_hostname() {
    case "$OSTYPE" in
    linux* | darwin*)
        hostname
        ;;
    cygwin* | msys* | win32*)
        powershell -NoProfile -Command "[System.Net.Dns]::GetHostName()"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac
}

# Function: Normalize paths
normalize_path() {
    local path="$1"
    local normalized_path

    case "$OSTYPE" in
    linux*)
        if command -v realpath >/dev/null 2>&1; then
            # Use `realpath -m` for non-existent paths on Linux
            normalized_path=$(realpath -m "$path" 2>/dev/null || echo "$(realpath -m "$(dirname "$path")")/$(basename "$path")")
        else
            echo "realpath not found on Linux" >&2
            exit 1
        fi
        ;;
    darwin*)
        if command -v grealpath >/dev/null 2>&1; then
            # Use `grealpath -m` for non-existent paths on macOS
            normalized_path=$(grealpath -m "$path" 2>/dev/null || echo "$(grealpath -m "$(dirname "$path")")/$(basename "$path")")
        else
            echo "grealpath not found on macOS. Install it using 'brew install coreutils'" >&2
            exit 1
        fi
        ;;
    cygwin* | msys* | win32*)
        # Use PowerShell to resolve the path on Windows
        normalized_path=$(powershell -NoProfile -Command "try { (Resolve-Path -LiteralPath '$path').Path } catch { [System.IO.Path]::GetFullPath('$path') }")
        ;;
    *)
        echo "Unsupported OS: $OSTYPE" >&2
        exit 1
        ;;
    esac

    echo "$normalized_path"
}

# Function: Normalize filenames
normalize_filename() {
    local filename="$1"
    filename=$(echo "$filename" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -d '\\/:*?"<>|')
    echo "$filename"
}

# Function: Get the root configuration directory and set the config file path
get_config_path() {
    local append_path="$1"
    local config_dir

    case "$OSTYPE" in
    linux* | darwin*)
        config_dir="$HOME/.config"
        ;;
    cygwin* | msys* | win32*)
        config_dir="$APPDATA\\"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    local full_path="$config_dir/$append_path"
    echo "$(normalize_path "$full_path")"
}

# Function: Get the temporary directory path
get_temp_path() {
    local append_path="$1"
    local temp_dir

    case "$OSTYPE" in
    linux* | darwin*)
        temp_dir="/tmp"
        ;;
    cygwin* | msys* | win32*)
        temp_dir="$TEMP"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    local full_path="$temp_dir/$append_path"
    echo "$(normalize_path "$full_path")"
}

# Function: Edit a specified file
edit_file() {
    local file="$1"

    if [[ -z "$file" ]]; then
        log_message "FATAL" "No file specified to edit." "$LINENO"
        exit 1
    fi

    if [[ ! -f "$file" ]]; then
        log_message "FATAL" "File not found: $file" "$LINENO"
        exit 1
    fi

    if [[ -n "$EDITOR" ]]; then
        if command -v "$EDITOR" &>/dev/null; then
            "$EDITOR" "$file"
            exit 0
        else
            log_message "FATAL" "Specified editor '$EDITOR' is not available." "$LINENO"
            exit 1
        fi
    fi

    case "$OSTYPE" in
    darwin*)
        open "$file"
        ;;
    linux*)
        xdg-open "$file"
        ;;
    cygwin* | msys* | win32*)
        start "" "$file"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    exit 0
}

# Function: Convert a frequency/interval string to seconds
get_interval_in_seconds() {
    local input_frequency="$1" # Input frequency/interval string
    local interval             # Variable to store the converted interval in seconds

    # Check if the input is a number without any unit
    if [[ "$input_frequency" =~ ^[0-9]+$ ]]; then
        interval=$input_frequency # Default to seconds if no unit is specified
    else
        # Determine the unit and convert accordingly
        case "${input_frequency: -1}" in
        s) interval=${input_frequency%?} ;;              # Seconds
        m) interval=$((${input_frequency%?} * 60)) ;;    # Minutes to seconds
        h) interval=$((${input_frequency%?} * 3600)) ;;  # Hours to seconds
        d) interval=$((${input_frequency%?} * 86400)) ;; # Days to seconds
        *)
            echo "Invalid frequency format"
            return 1
            ;; # Handle invalid formats
        esac
    fi

    echo "$interval" # Return the interval in seconds
}

# Function: Convert date to human-readable format
convert_date() {
    local date_str="$1"
    local human_readable_date

    if [[ "$OSTYPE" == "linux"* ]]; then
        human_readable_date=$(date -d "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        human_readable_date=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    elif [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
        human_readable_date=$(date -d "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    else
        human_readable_date="$date_str"
    fi

    echo "$human_readable_date"
}

# ==============================
# Logging and Messaging Functions
# ==============================

# Function: Check if the current log level is at or above a given level
log_at_or_above() {
    local level_name=$1

    # Get indices from the associative array
    local current_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    local check_level_index=${LOG_LEVELS_MAP[$level_name]}

    # Compare indices
    if [[ $current_level_index -ge $check_level_index ]]; then
        return 0 # true: log level is at or above the given level
    else
        return 1 # false: log level is below the given level
    fi
}

# Function: Log messages to console
log_to_console() {
    local log_level_name=$1
    local message=$2
    local line_number=$3
    # Generate an ISO 8601 timestamp in UTC
    local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
    local output_message="$message"

    # If verbose mode or debug level is enabled, format the output with timestamp and log level
    if [[ "$VERBOSE" = true || "$LOG_LEVEL" = "DEBUG" ]]; then
        output_message="$timestamp [$log_level_name] $message (Line: $line_number)"
    fi

    # Escape special characters to avoid issues with printf
    local safe_message=$(printf "%s" "$output_message" | sed 's/[^[:print:]\t]//g') # Remove non-printable characters

    # Handle different log levels
    case $log_level_name in
    "FATAL")
        printf "${RED_BG}%b${NC}\n" "$safe_message" >&2
        ;;
    "ERROR")
        printf "${RED}%b${NC}\n" "$safe_message" >&2
        ;;
    "WARN")
        printf "${YELLOW}%b${NC}\n" "$safe_message" >&2
        ;;
    *)
        printf "%b${NC}\n" "$safe_message" >&2
        ;;
    esac
}

# Function: Log messages
log_message() {
    local log_level_name=$1
    local message=$2
    local line_number=${3:-"N/A"}
    local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")

    # Validate log level name
    local log_level_index=${LOG_LEVELS_MAP[$log_level_name]}
    if [[ -z "$log_level_index" ]]; then
        log_level_name="INFO"
        log_level_index=${LOG_LEVELS_MAP[$log_level_name]}
        printf "%s\n" "$timestamp [ERROR] Invalid log level specified. Defaulting to INFO." >&2
    fi

    # Validate current log level
    local current_log_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    if [[ -z "$current_log_level_index" ]]; then
        printf "%s\n" "$timestamp [ERROR] Invalid global log level. Defaulting to INFO." >&2
        LOG_LEVEL="INFO"
        current_log_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    fi

    # Format the log message
    local formatted_message="$timestamp [$log_level_name] $message"
    if [[ "$VERBOSE" = true || "$LOG_LEVEL" = "DEBUG" ]]; then
        formatted_message="$formatted_message (Line: $line_number)"
    fi

    # Escape special characters in the message to prevent breaking formatting
    local safe_message=$(printf "%s" "$formatted_message" | sed 's/[^[:print:]\t]//g')

    # Log to file if the log level meets the criteria and the log file exists
    if log_at_or_above "$log_level_name" && [[ -f "$LOG_FILE" ]]; then
        printf "%s\n" "$safe_message" >>"$LOG_FILE" 2>/dev/null || true
    fi

    # Always log to the console if not running as a service, or if no log file exists
    if [[ "$IS_SERVICE" != true || ! -f "$LOG_FILE" ]] && log_at_or_above "$log_level_name"; then
        log_to_console "$log_level_name" "$message" "$line_number"
    fi
}

# Function: Initialize the log file
init_log() {
    # Ensure the directory for the log file exists
    log_dir=$(dirname "$LOG_FILE")
    if [ ! -d "$log_dir" ]; then
        printf "Log file directory %s does not exist. Creating it...\n" "$log_dir"
        mkdir -p "$log_dir" || {
            log_message "FATAL" "Failed to create directory: $log_dir" "$LINENO"
            exit 1
        }
    fi

    if [ -z "$LOG_FILE" ]; then
        log_message "FATAL" "LOG_FILE variable is not set." "$LINENO"
        exit 1
    fi

    if [ ! -f "$LOG_FILE" ]; then
        # Attempt to create the log file
        if touch "$LOG_FILE" 2>/dev/null; then
            log_message "DEBUG" "Created log file: $LOG_FILE" "$LINENO"
        else
            log_message "FATAL" "Failed to create log file: $LOG_FILE" "$LINENO"
            exit 1
        fi
    else
        # Check if the log file is writable
        if [ ! -w "$LOG_FILE" ]; then
            log_message "FATAL" "Log file exists but is not writable: $LOG_FILE" "$LINENO"
            exit 1
        fi
        log_message "DEBUG" "Log file already exists and is writable: $LOG_FILE" "$LINENO"
    fi
}

# Function: Log the log file to the screen
show_log() {
    if [ -f "$LOG_FILE" ]; then
        cat "$LOG_FILE"
    else
        log_message "INFO" "Log file not found: $LOG_FILE" "$LINENO"
    fi
    exit 0
}

# ==============================
# Cache Management Functions
# ==============================

# Function: Check if a directory is a mount point
is_mount_point() {
    local dir="$1"

    if [[ "$OSTYPE" == "linux"* ]]; then
        # Use `findmnt` if available on Linux
        if command -v findmnt >/dev/null 2>&1; then
            findmnt -n -o TARGET --target "$dir" >/dev/null 2>&1
            return $?
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS: Use `df` to check if the directory is a separate mount
        if [[ $(df "$dir" 2>/dev/null | tail -n +2 | awk '{print $NF}') == "$dir" ]]; then
            return 0
        fi
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        # Windows: Skip mount point check as it's less relevant for typical use cases
        return 1
    fi

    # Default: Assume it's not a mount point
    return 1
}

# Function: Check if a directory is critical
is_critical_directory() {
    local dir="$1"
    local critical_dirs=(
        "/" "/home" "/bin" "/boot" "/dev" "/etc" "/lib" "/lib64" "/proc" "/root" "/sbin" "/sys" "/usr" "/var" "/tmp"
        "C:\\" "C:\\Windows" "C:\\Program Files" "C:\\Program Files (x86)" "C:\\Users" "C:\\Documents and Settings"
    )

    # Check if the directory is in the list of critical directories
    for critical_dir in "${critical_dirs[@]}"; do
        if [[ "$dir" == "$critical_dir" ]]; then
            return 0 # true: critical directory
        fi
    done

    # Protect symbolic links
    if [[ -L "$dir" ]]; then
        return 0 # true: critical directory
    fi

    # Check if the directory is a mount point (cross-platform)
    if is_mount_point "$dir"; then
        return 0 # true: critical directory
    fi

    return 1 # false: not a critical directory
}

# Function: Delete all cached files
delete_cache() {
    log_message "INFO" "Deleting all cached files..." "$LINENO"

    # Ensure CACHE_DIR is defined and not empty
    if [[ -z "$CACHE_DIR" ]]; then
        log_message "FATAL" "CACHE_DIR is not set. Unable to proceed." "$LINENO"
        exit 1
    fi

    # Ensure CACHE_DIR exists
    if [[ ! -d "$CACHE_DIR" ]]; then
        log_message "FATAL" "Cache directory '$CACHE_DIR' does not exist." "$LINENO"
        exit 1
    fi

    # Prevent deletion of critical directories
    if is_critical_directory "$CACHE_DIR"; then
        log_message "FATAL" "Attempted to delete a critical directory '$CACHE_DIR'. Aborting." "$LINENO"
        exit 1
    fi

    # Attempt to delete the cache directory
    if rm -rf "$CACHE_DIR"; then
        log_message "INFO" "Success: All cached files in '$CACHE_DIR' deleted." "$LINENO"
        exit 0
    else
        log_message "FATAL" "Failed to delete cached files in '$CACHE_DIR'." "$LINENO"
        exit 1
    fi
}

# Function: Initialize the cache directory
init_cache() {
    # Create the master cache directory and log file if they don't exist
    if [ ! -d "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR"
        log_message "DEBUG" "Created cache directory: $CACHE_DIR" "$LINENO"
    else
        log_message "DEBUG" "Cache directory already exists: $CACHE_DIR" "$LINENO"
    fi
}

# ==============================
# Notification Functions
# ==============================

# Function: Send desktop notifications
send_desktop_notification() {
    local title="$1"
    local message="$2"

    if [ "$DESKTOP_NOTIFICATION" = true ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ! osascript -e "display notification \"$message\" with title \"$title\""; then
                log_message "ERROR" "Failed to send notification on macOS." "$LINENO"
            fi
        elif [[ "$OSTYPE" == "linux"* ]]; then
            if command -v notify-send &>/dev/null; then
                notify-send "$title" "$message"
            else
                log_message "ERROR" "notify-send is not installed. Install it to enable notifications on Linux." "$LINENO"
            fi
        elif [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
            if ! powershell -Command "[System.Windows.Forms.MessageBox]::Show('$message', '$title')"; then
                log_message "ERROR" "Failed to send notification on Windows." "$LINENO"
            fi
        else
            log_message "ERROR" "Desktop notifications are only supported on macOS, Linux, and Windows." "$LINENO"
        fi
    fi
}

# Function: Send Pushover notifications
send_pushover_notification() {
    local title=$1
    local message=$2
    local website_url=$3
    local response

    if [ "$PUSHOVER_NOTIFICATION" = true ]; then
        log_message "DEBUG" "Processing Pushover notification: $website_url" "$LINENO"
        log_message "DEBUG" "Url: $website_url" "$LINENO"
        log_message "DEBUG" "Message: $message" "$LINENO"

        # Check if PUSHOVER_API_TOKEN is set
        if [[ -z "$PUSHOVER_API_TOKEN" ]]; then
            log_message "ERROR" "Error: PUSHOVER_API_TOKEN is not set." "$LINENO"
            return 1
        fi

        # Check if USER_KEY is set
        if [[ -z "$PUSHOVER_USER_KEY" ]]; then
            log_message "ERROR" "Error: PUSHOVER_USER_KEY is not set." "$LINENO"
            return 1
        fi

        # Build the curl command
        local curl_command="curl -s \
            --form-string \"token=$PUSHOVER_API_TOKEN\" \
            --form-string \"user=$PUSHOVER_USER_KEY\" \
            --form-string \"title=$title\" \
            --form-string \"message=$message\" \
            --form \"priority=0\" \
            https://api.pushover.net/1/messages.json"

        # Add URL options if website_url is defined
        if [[ -n "$website_url" ]]; then
            curl_command+=" --form \"url=$website_url\" --form \"url_title=Visit Site\""
        fi

        # Execute the curl command
        response=$(eval $curl_command)

        if [[ $? -ne 0 || -z "$response" ]]; then
            log_message "ERROR" "Failed to send Pushover notification for: $website_url" "$LINENO"
            return 1
        fi

        # Extract the status from the JSON response
        local status=$(echo "$response" | grep -o '"status":[0-9]*' | sed 's/"status"://')

        # Check if status is 1 (success)
        if [[ "$status" != "1" ]]; then
            log_message "ERROR" "Pushover API returned an error: $response" "$LINENO"
            return 1
        fi

        log_message "DEBUG" "Pushover notification sent successfully." "$LINENO"
        return 0
    fi
}

# ==============================
# Process Execution Functions
# ==============================

# Function: Start the service
start_service() {
    # Set up the trap for cleanup on app exit
    trap 'cleanup_pid' EXIT

    log_message "INFO" "Starting $APP_NAME service..." "$LINENO"

    # Launch the service as a background process in a subshell
    (
        main >/dev/null 2>&1 &
        local service_pid=$!

        # Sleep briefly to ensure the background process has initialized
        sleep 3

        # Verify that the background process is running by checking the PID
        if kill -0 "$service_pid" >/dev/null 2>&1; then
            IS_SERVICE=true
            # Write the PID to the file
            echo "$service_pid" >"$PID_FILE"
            log_message "DEBUG" "$APP_NAME service started with PID $service_pid." "$LINENO"
        else
            # If the process failed to start, clean up and exit
            log_message "FATAL" "Failed to start $APP_NAME service. PID is not valid." "$LINENO"
            cleanup_pid
            exit 1
        fi
    ) &

    # The service is now running in the background
    log_message "INFO" "$APP_NAME service is running in the background." "$LINENO"
}

# Function: Stop the service
stop_service() {
    if [[ ! -f "$PID_FILE" ]]; then
        log_message "INFO" "No $APP_NAME service is currently running." "$LINENO"
        exit 0
    fi

    local pid
    pid=$(cat "$PID_FILE")
    if kill -0 "$pid" >/dev/null 2>&1; then
        log_message "INFO" "Stopping $APP_NAME service with PID $pid..." "$LINENO"
        kill "$pid"
        cleanup_pid
        log_message "INFO" "$APP_NAME service stopped." "$LINENO"
    else
        log_message "WARN" "No active $APP_NAME process found for PID $pid. Cleaning up stale PID file." "$LINENO"
        cleanup_pid
    fi
}

# Function: Restart the service
restart_service() {
    if [[ ! -f "$PID_FILE" ]]; then
        log_message "INFO" "No $APP_NAME service is currently running." "$LINENO"
        exit 0
    fi

    log_message "INFO" "Restarting $APP_NAME service with PID $pid..." "$LINENO"
    stop_service
    start_service
}

# Function: Check the status of the service
status_service() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" >/dev/null 2>&1; then
            log_message "INFO" "$APP_NAME service is running with PID $pid." "$LINENO"
        else
            log_message "WARN" "$APP_NAME service is not running, but PID file exists. Cleaning up stale PID file." "$LINENO"
            cleanup_pid
        fi
    else
        log_message "INFO" "$APP_NAME service is not running." "$LINENO"
    fi
}

# Function: Prevent running multiple interactive instances (except for specific cases)
check_already_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" >/dev/null 2>&1; then
            log_message "ERROR" "Another instance of the $APP_NAME is already running (PID: $pid)." "$LINENO"
            exit 1
        else
            log_message "WARN" "Stale $APP_NAME PID file found. Cleaning up." "$LINENO"
            rm -f "$PID_FILE"
        fi
    fi
}

# Function: Cleanup PID file on exit
cleanup_pid() {
    # Ensure the PID file exists before attempting to clean it up
    if [[ -f "$PID_FILE" ]]; then
        log_message "DEBUG" "Cleaning up $APP_NAME PID file and exiting." "$LINENO"
        rm -f "$PID_FILE"
    fi
}

# Function: Run the check
start_process() {
    # Handle status or stop service before checking for running instances
    if [[ "$SHOW_STATUS" == true ]]; then
        status_service
        exit 0
    fi

    if [[ "$STOP_SERVICE" == true ]]; then
        stop_service
        exit 0
    fi

    # Check if an instance is already running
    if [[ "$RESTART_SERVICE" == true ]]; then
        restart_service
    else
        check_already_running

        # Log and start the configuration
        log_message "INFO" "Starting $APP_NAME: $(date)" "$LINENO"
        show_config

        # Start the service or run interactively
        if [[ "$START_SERVICE" == true ]]; then
            start_service
        else
            log_message "INFO" "Running $APP_NAME interactively..." "$LINENO"
            # Set up a trap for cleanup on termination
            trap 'cleanup_pid' EXIT
            echo $$ >"$PID_FILE"
            main
        fi
    fi
}

# ==============================
# Configuration and Initialization Functions
# ==============================

# Function: Load configuration from JSON file
load_config() {
    local config_file_path="$1"

    if key_exists "CONFIG_FILE" SKIP_CONFIG_KEYS[@] && [[ ! -f "$config_file_path" ]]; then
        log_message "FATAL" "Configuration file not found: $config_file_path" "$LINENO"
        exit 1
    elif ! key_exists "CONFIG_FILE" SKIP_CONFIG_KEYS[@] && [[ ! -f "$config_file_path" ]]; then
        return 0
    fi

    # Use jq to parse the JSON and set environment variables
    local jq_output
    jq_output=$(jq -r '.configuration | to_entries | .[] | "\(.key)=\(.value)"' "$config_file_path")
    log_message "DEBUG" "Configuration file settings: $jq_output" "$LINENO"

    while IFS="=" read -r key value; do
        # Skip empty lines, invalid entries, or keys that are in the skip_keys array
        if [[ -n "$key" && -n "$value" && ! " ${SKIP_CONFIG_KEYS[@]} " =~ " ${key} " && "$key" != "CONFIG_FILE" ]]; then
            [[ "$key" == *_DIR || "$key" == *_FILE || "$key" == *_CMD ]] && value="$(normalize_path "$value")"
            export "$key"="$value"
            log_message "DEBUG" "Setting $key=$value" "$LINENO"
        fi
    done <<<"$jq_output"
}

# Function: Get all "connections" groups and return them in an array
get_connection_groups() {
    local config_file_path="$1"
    jq -r '.urls | keys | sort[]' "$config_file_path"
}

# Function: Check if a key exists in the SKIP_CONFIG_KEYS
key_exists() {
    local key="$1"

    if [[ " ${SKIP_CONFIG_KEYS[@]} " =~ " ${key} " ]]; then
        return 0 # Key exists
    fi

    return 1 # Key does not exist
}

# Function: Get URL settings as key-value pairs
get_url_settings() {
    local group="$1"
    local index="$2"
    local config_file_path="$3"
    local -n result_array=$4

    while IFS="=" read -r key value; do
        result_array["$key"]="$value"
        log_message "DEBUG" "$key=$value" "$LINENO"
    done < <(jq -r ".urls[\"$group\"][$index] | to_entries | map(\"\\(.key)=\\(.value)\") | .[]" "$config_file_path")
}

# Function: Show configuration file
show_config_file() {
    log_message "INFO" "Configuration file: $CONFIG_FILE" "$LINENO"
    log_message "INFO" "" "$LINENO"
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE"
    else
        log_message "ERROR" "Configuration file not found: $CONFIG_FILE" "$LINENO"
    fi
    log_message "INFO" "" "$LINENO"
    exit 0
}

# Function: Initialize the configuration file
init_config() {
    # Ensure the directory for the configuration file exists
    config_dir=$(dirname "$CONFIG_FILE")
    if [ ! -d "$config_dir" ]; then
        printf "Configuration file directory %s does not exist. Creating it...\n" "$config_dir"
        mkdir -p "$config_dir" || {
            log_message "FATAL" "Failed to create directory: $config_dir" "$LINENO"
            exit 1
        }
    fi

    # Check if the configuration file already exists
    if [ -f "$CONFIG_FILE" ]; then
        if [ "$INIT_FORCE" = true ]; then
            printf "FORCE is true. Replacing the existing configuration file...\n"
        else
            read -p "Configuration file $CONFIG_FILE already exists. Do you want to replace it? (y/n): " choice
            case "$choice" in
            y | Y)
                printf "Replacing the existing configuration file...\n"
                ;;
            n | N)
                printf "Keeping the existing configuration file.\n"
                return
                ;;
            *)
                printf "Invalid choice. Keeping the existing configuration file.\n"
                return
                ;;
            esac
        fi
    fi

    # Create the configuration content
    config_content=$(
        cat <<EOF
{
	"configuration": {
		"CACHE_DIR": "$CACHE_DIR",
		"LOG_FILE": "$LOG_FILE",
		"CHECK_INTERVAL": "$CHECK_INTERVAL",
		"TIMEOUT": "$TIMEOUT",
		"SYSTEM_NAME": "$SYSTEM_NAME",
		"PUSHOVER_NOTIFICATION": "$PUSHOVER_NOTIFICATION",
		"PUSHOVER_USER_KEY": "$PUSHOVER_USER_KEY",
		"PUSHOVER_API_TOKEN": "$PUSHOVER_API_TOKEN",
		"DESKTOP_NOTIFICATION": "$DESKTOP_NOTIFICATION",
		"VERBOSE": "$VERBOSE",
		"LOG_LEVEL": "$LOG_LEVEL",
		"URL_FILE": "$URL_FILE",
		"THRESHOLD": "$THRESHOLD"
    },
	"urls": {
		"default": [
			{
				"NAME": "Apple Newsroom",
				"URL": "https://www.apple.com/newsroom/",
				"TIMEOUT": "5s",
				"THRESHOLD": "1",
				"UPDATED_CMD": "",
                "CMD_TIMEOUT": "5s"
			},
			{
				"NAME": "9to5mac Homepage",
				"URL": "https://9to5mac.com",
				"TIMEOUT": "10s",
				"THRESHOLD": "15",
				"UPDATED_CMD": "",
                "CMD_TIMEOUT": "5s"
			}
		]
	}
}
EOF
    )

    # Write the configuration content to the file
    if ! echo "$config_content" >"$CONFIG_FILE"; then
        log_message "FATAL" "Failed to create configuration file at $CONFIG_FILE" "$LINENO"
        exit 1
    fi

    log_message "INFO" "Default configuration file created at $CONFIG_FILE" "$LINENO"
    exit 0
}

# Function: Show configuration information
show_config() {
    log_message "INFO" "Configuration file: $CONFIG_FILE" "$LINENO"
    log_message "INFO" "Cache directory: $CACHE_DIR" "$LINENO"
    log_message "INFO" "Log file: $LOG_FILE" "$LINENO"
    log_message "INFO" "PID file: $PID_FILE" "$LINENO"
    log_message "INFO" "Log Level: $LOG_LEVEL" "$LINENO"
    log_message "INFO" "Verbose enabled: $VERBOSE" "$LINENO"
    log_message "INFO" "System Name: $SYSTEM_NAME" "$LINENO"
    log_message "INFO" "Pushover enabled: $PUSHOVER_NOTIFICATION" "$LINENO"
    log_message "INFO" "Desktop notification enabled: $DESKTOP_NOTIFICATION" "$LINENO"
    log_message "INFO" "Check interval: $CHECK_INTERVAL" "$LINENO"
    log_message "INFO" "Timeout interval: $TIMEOUT" "$LINENO"
    log_message "INFO" "Repeat times: ${REPEAT:-0}" "$LINENO"
    log_message "INFO" "Threshold for changes: $THRESHOLD" "$LINENO"
}

# ==============================
# Help Functions
# ==============================

# Function: Show help message
show_help() {
    printf "Usage: %s <url>... [options]\n" "$(basename "$0")"

    # General Options
    printf "\nGeneral Options:\n"
    printf "  -h, --help                  Display this help message.\n"
    printf "  -V, --version               Display the application version.\n"

    # Configuration and Initialization
    printf "\nConfiguration and Initialization:\n"
    printf "  -c, --config <config_file>  Specify a custom configuration file (default: %s).\n" "${CONFIG_FILE}"
    printf "  -i, --init                  Initialize the configuration file.\n"
    printf "  -f, --force-init            Force initialize of the configuration file if one exists.\n"
    printf "  -S, --show-config           Show the configuration settings.\n"
    printf "  -e, --show-config-file      Show the configuration file.\n"
    printf "  -E, --edit-config           Edit the configuration file.\n"

    # Cache Management
    printf "\nCache Management:\n"
    printf "  -x, --clean                 Delete all cached files.\n"
    printf "  -C, --cache-dir  <path>     Specify a custom cache directory (default: %s).\n" "${CACHE_DIR}"

    # Notification Options
    printf "\nNotification Options:\n"
    printf "  -n, --system-name           Name of the system running the script (default: %s).\n" "${SYSTEM_NAME}"
    printf "  -p, --pushover              Send Pushover notifications.\n"
    printf "  -u, --user-key <key>        Specify the user key for Pushover notifications.\n"
    printf "  -a, --api-token <token>     Specify the API token for Pushover notifications.\n"
    printf "  -d, --desktop               Send desktop notifications using AppleScript.\n"

    # Logging and Output
    printf "\nLogging and Output:\n"
    printf "  -v, --verbose               Enable verbose output.\n"
    printf "  -l, --log                   Log the log file to the screen.\n"
    printf "  -o, --output <file>         Specify a custom log file location (default: %s).\n" "${LOG_FILE}"
    printf "  -L, --log-level <level>     Set the log level (FATAL, ERROR, WARN, INFO, DEBUG).\n"

    # Remote Connection Configuration
    printf "\nRemote Connection Configuration:\n"
    printf "  -I, --interval <s,m,h,d>    Set the interval between checks (default: %s).\n" "${CHECK_INTERVAL}"
    printf "  -T, --timeout <s,m,h,d>     Set the connection timeout for remote connections (default: %s).\n" "${TIMEOUT}"
    printf "  -N, --repeat <number>       Repeat the checks in interactive mode N number of times and exit (default: %s).\n" "${REPEAT:-0}"
    printf "  -H, --threshold <percentage> Set the default threshold percentage for detecting changes. Higher values mean fewer notifications for minor changes. (default: %d%%)\n" "$THRESHOLD"
    printf "  -U, --list-urls             List all watched URLs.\n"

    # Process Management Functions
    printf "\nProcess Management:\n"
    printf "  -s, --start                 Start the %s service in the background.\n" "${APP_NAME}"
    printf "  -k, --stop                  Stop the %s service.\n" "${APP_NAME}"
    printf "  -r, --restart               Restart the %s service.\n" "${APP_NAME}"
    printf "  -t, --status                Check the current status of the %s service.\n" "${APP_NAME}"

    # Examples
    printf "\nExamples:\n"
    printf "  Run interactively with default settings:\n"
    printf "    %s 'https://example.com'\n" "$(basename "$0")"
    printf "\n"
    printf "  Specify a threshold for a specific URL. This overrides the global threshold setting.\n"
    printf "    %s '[15]https://example.com'\n" "$(basename "$0")"
    printf "\n"
    printf "  Start the service with URLS:\n"
    printf "    %s --start 'https://example.com'\n" "$(basename "$0")"
    printf "\n"
    printf "  Start the service with default settings:\n"
    printf "    %s --start\n" "$(basename "$0")"
    printf "\n"
    printf "  Restart the service with default settings:\n"
    printf "    %s --restart\n" "$(basename "$0")"
    printf "\n"
    printf "  Check service status:\n"
    printf "    %s --status\n" "$(basename "$0")"
    printf "\n"
    printf "  Stop the service:\n"
    printf "    %s --stop\n" "$(basename "$0")"
    printf "\n"
}

# ==============================
# Argument Processing Functions
# ==============================

# Function: Parse command-line arguments and setup environment
parse_cli_options() {

    # Default configuration file locations
    CONFIG_FILE="$(get_config_path "$CONFIG_FILE_NAME")"
    CACHE_DIR="$(get_temp_path "$CACHE_DIR")"
    LOG_FILE="$(normalize_path "$CACHE_DIR/$LOG_FILE_NAME")"

    # Set default hostname
    SYSTEM_NAME="$(get_hostname)"

    # Process high priority items first
    [[ " $@ " =~ " --help " || " $@ " =~ " -h " ]] && show_help && show_version && exit 0
    [[ " $@ " =~ " --version " || " $@ " =~ " -V " ]] && show_version && exit 0

    # Check for log level and verbose and process so they are available early
    if [[ " $@ " =~ " --log-level " || " $@ " =~ " -L " ]]; then
        for ((i = 1; i <= $#; i++)); do
            case "${!i}" in
            --log-level | -L)
                next=$((i + 1))
                if [[ -z "${!next}" || "${!next}" == -* ]]; then
                    printf "Error: %s requires a value\n" "${!i}" >&2
                    exit 1
                fi
                # Check if the log level exists in the LOG_LEVELS_MAP array
                if [[ -n "${LOG_LEVELS_MAP[${!next}]}" ]]; then
                    LOG_LEVEL="${!next}"
                    SKIP_CONFIG_KEYS+=("LOG_LEVEL")
                else
                    printf "Error: %s requires a valid value. Available levels are: %s\n" "${!i}" "${!LOG_LEVELS_MAP[*]}" >&2
                    exit 1
                fi
                # Remove the processed options from the arguments list
                set -- "${@:1:$((i - 1))}" "${@:((i + 2))}"
                i=$((i - 1))
                ;;
            --verbose | -v)
                VERBOSE=true
                SKIP_CONFIG_KEYS+=("VERBOSE")
                # Remove the processed options from the arguments list
                set -- "${@:1:$((i - 1))}" "${@:((i + 1))}"
                i=$((i - 1))
                ;;
            esac
        done
    fi

    # Process remaining options
    local options_processed=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
        # Configuration and Initialization
        --config | -c)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CONFIG_FILE="$(normalize_path "$2")"
            SKIP_CONFIG_KEYS+=("CONFIG_FILE")
            shift 2
            ;;
        --init | -i)
            INIT=true
            shift
            ;;
        --force-init | -f)
            INIT_FORCE=true
            shift
            ;;
        --show-config | -S)
            SHOW_CONFIG=true
            shift
            ;;
        --show-config-file | -e)
            SHOW_CONFIG_FILE=true
            shift
            ;;
        --edit-config | -E)
            EDIT_CONFIG_FILE=true
            shift
            ;;

        # Cache Management
        --clean | -x)
            CLEAN=true
            shift
            ;;
        --cache-dir | -C)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CACHE_DIR="$(normalize_path "$2")"
            LOG_FILE="$(normalize_path "$2/$LOG_FILE_NAME")"
            SKIP_CONFIG_KEYS+=("CACHE_DIR")
            shift 2
            ;;

        # Notification Options
        --system-name | -n)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            SYSTEM_NAME="$2"
            SKIP_CONFIG_KEYS+=("SYSTEM_NAME")
            shift 2
            ;;
        --pushover | -p)
            PUSHOVER_NOTIFICATION=true
            SKIP_CONFIG_KEYS+=("PUSHOVER_NOTIFICATION")
            shift
            ;;
        --user-key | -u)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            PUSHOVER_USER_KEY="$2"
            SKIP_CONFIG_KEYS+=("PUSHOVER_USER_KEY")
            shift 2
            ;;
        --api-token | -a)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            PUSHOVER_API_TOKEN="$2"
            SKIP_CONFIG_KEYS+=("PUSHOVER_API_TOKEN")
            shift 2
            ;;
        --desktop | -d)
            DESKTOP_NOTIFICATION=true
            SKIP_CONFIG_KEYS+=("DESKTOP_NOTIFICATION")
            shift
            ;;

        # Logging and Output
        --log | -l)
            SHOW_LOG=true
            shift
            ;;
        --output | -o)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            LOG_FILE="$(normalize_path "$2")"
            SKIP_CONFIG_KEYS+=("LOG_FILE")
            shift 2
            ;;

        # Remote Connection Configuration
        --interval | -I)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CHECK_INTERVAL="$2"
            SKIP_CONFIG_KEYS+=("CHECK_INTERVAL")
            shift 2
            ;;
        --timeout | -T)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            TIMEOUT="$2"
            SKIP_CONFIG_KEYS+=("TIMEOUT")
            shift 2
            ;;
        --repeat | -N)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                printf "Error: Timeout must be an integer\n" >&2
                exit 1
            fi
            REPEAT="$2"
            SKIP_CONFIG_KEYS+=("REPEAT")
            shift 2
            ;;
        --list-urls | -U)
            SHOW_URLS=true
            shift
            ;;
        --threshold | -H)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: --threshold requires a value\n"
                exit 1
            fi
            THRESHOLD="$2"
            SKIP_CONFIG_KEYS+=("THRESHOLD")
            shift 2
            ;;

        # Process Management
        --start | -s)
            START_SERVICE=true
            shift
            ;;
        --stop | -k)
            STOP_SERVICE=true
            shift
            ;;
        --restart | -r)
            RESTART_SERVICE=true
            shift
            ;;
        --status | -t)
            SHOW_STATUS=true
            shift
            ;;

        # End of Options
        --)
            options_processed=true
            shift
            break
            ;;

            # All remaining input is invalid
        -*)
            printf "Error: Unknown option: %s\n" "$1" >&2
            exit 1
            ;;
        *)
            if [[ "$1" == -* ]]; then
                printf "Error: Unknown option: %s\n" "$1" >&2
                exit 1
            fi
            CLI_URLS+=("$1")
            shift
            ;;
        esac
    done

    # Check for cache critical path
    if is_critical_directory "$CACHE_DIR"; then
        log_message "FATAL" "Attempted to set cache path to a critical directory '$CACHE_DIR'. Aborting." "$LINENO"
        exit 1
    fi

    # Delete the cache directory and exit
    [[ "$CLEAN" = true ]] && delete_cache

    # Initialize the default configuration file and exit
    [[ -z "$INIT" || "$INIT" = false ]] && load_config "$CONFIG_FILE"
    [[ "$INIT" = true ]] && init_config
    init_cache
    init_log

    # Set the PID file based on final CACHE_DIR
    PID_FILE="$(normalize_path "$CACHE_DIR/$PID_FILE_NAME")"

    # Process final commands after configuration is completely finalized
    [[ "$EDIT_CONFIG_FILE" = true ]] && edit_file "$CONFIG_FILE"
    [[ "$SHOW_LOG" = true ]] && show_log
    [[ "$SHOW_CONFIG_FILE" = true ]] && show_config_file

    # Run a final processing of arguments
    process_arguments
}

# Function: Process and execute actions based on parsed arguments
process_arguments() {
    # Show URLs and exit
    [[ "$SHOW_URLS" = true ]] && show_urls && exit 0

    # Keep this last so we show the final configuration state
    [[ "$SHOW_CONFIG" = true ]] && show_config && show_version && exit
}

# ==============================
# Application Functions
# ==============================

# Function: Show URL configuration file
show_urls() {
    log_message "INFO" "Configured URLs:" "$LINENO"

    # Get the connection groups
    local groups=($(get_connection_groups "$CONFIG_FILE"))

    # Check if groups array is empty or null
    if [[ ${#groups[@]} -eq 0 ]]; then
        log_message "FATAL" "No connection groups found in the configuration file." "$LINENO"
        exit 1
    fi

    # Process the remaining groups
    for group in "${groups[@]}"; do
        log_message "INFO" "Group: $group" "$LINENO"
        urls=$(jq -r ".urls[\"$group\"] | length" "$CONFIG_FILE")
        for ((i = 0; i < urls; i++)); do
            local -A url_result
            get_url_settings "$group" "$i" "$CONFIG_FILE" url_result
            log_message "INFO" "- Name: ${url_result["NAME"]}" "$LINENO"
            log_message "INFO" "- URL: ${url_result["URL"]}" "$LINENO"
            log_message "INFO" "- Threshold: ${url_result["THRESHOLD"]}" "$LINENO"
            log_message "INFO" "- Timeout: ${url_result["TIMEOUT"]}" "$LINENO"
            log_message "INFO" "- Updated Command: ${url_result["UPDATED_CMD"]}" "$LINENO"
        done
    done

    log_message "INFO" "" "$LINENO"
}

# Function: Normalize HTML content
normalize_content() {
    local file=$1
    local temp_file=$(mktemp)

    if [ ! -f "$file" ]; then
        log_message "ERROR" "Input file does not exist: $file" "$LINENO"
        return 1
    fi

    local base_filename=$(basename "$file")

    # Save raw HTML for inspection if the LOG_LEVEL is DEBUG
    if log_at_or_above "DEBUG"; then
        cp "$file" "$CACHE_DIR/${base_filename}_debug_raw_html.txt"
    fi

    # Use xmllint to filter out unwanted elements and normalize content
    xmllint --html --xpath "//*[not(self::script or self::style or self::footer or self::header or self::aside or self::nav or self::iframe or self::noscript or contains(@class, 'ad') or contains(@class, 'promo') or contains(@class, 'banner') or contains(@class, 'sponsored') or contains(@class, 'timestamp') or contains(@class, 'footer') or contains(@class, 'header') or contains(@class, 'sidebar') or contains(@id, 'ad') or contains(@id, 'promo') or contains(@id, 'banner') or contains(@id, 'sponsored') or contains(@id, 'timestamp') or contains(@id, 'footer') or contains(@id, 'header') or contains(@id, 'sidebar'))]" "$file" 2>/dev/null >"$temp_file"

    # If xmllint fails or the result is empty, warn and exit early
    if [ ! -s "$temp_file" ]; then
        log_message "WARN" "Normalized content is empty or failed to parse: $file" "$LINENO"
        rm -f "$temp_file"
        return 1
    fi

    # Clean and format the extracted content
    sed -i '' \
        -e '/<!--.*?-->/d' \
        -e 's/<[^>]*>//g' \
        -e 's/[[:space:]]+/ /g' \
        -e 's/^[[:space:]]*//g' \
        -e 's/[[:space:]]*$//g' \
        "$temp_file"

    # Debug: Save processed content for inspection if LOG_LEVEL is DEBUG
    if log_at_or_above "DEBUG"; then
        cp "$temp_file" "$CACHE_DIR/${base_filename}_debug_normalized.txt"
    fi

    # Replace the original file with the normalized content
    mv "$temp_file" "$file"
    log_message "DEBUG" "Content normalized successfully: $file" "$LINENO"
    return 0
}

# Function: Calculate change percentage
calculate_change_percentage() {
    local previous_file=$1
    local new_file=$2

    # Basic logging
    log_message "DEBUG" "Calculating change percentage" "$LINENO"
    log_message "DEBUG" "Previous file: $previous_file" "$LINENO"
    log_message "DEBUG" "New file: $new_file" "$LINENO"

    # Calculate the number of lines in the previous file
    if [ ! -f "$previous_file" ] || [ ! -f "$new_file" ]; then
        log_message "ERROR- One of the files for comparison does not exist." "$LINENO"
        echo 100 # Consider 100% change
        return 0
    fi

    local previous_lines=$(wc -l <"$previous_file" | xargs)
    local new_lines=$(wc -l <"$new_file" | xargs)

    log_message "DEBUG" "Previous lines: $previous_lines" "$LINENO"
    log_message "DEBUG" "New lines: $new_lines" "$LINENO"

    if [ "$previous_lines" -eq 0 ] && [ "$new_lines" -eq 0 ]; then
        log_message "INFO" "Both files are empty. Assuming no change." "$LINENO"
        echo 0
        return 0
    fi

    # Handle empty previous file
    if [ "$previous_lines" -eq 0 ]; then
        log_message "WARN" "Previous file is empty. Assuming 100% change." "$LINENO"
        echo 100
        return 0
    fi

    # Calculate the number of differing lines (additions and deletions)
    differing_lines=$(diff -U 0 "$previous_file" "$new_file" | grep -E '^\+|^-' | wc -l | xargs)

    # Calculate change percentage
    local change_percentage=$(awk "BEGIN {printf \"%.2f\", ($differing_lines / $previous_lines) * 100}" | xargs)
    log_message "DEBUG" "Differing lines: $differing_lines" "$LINENO"
    log_message "DEBUG" "Change percentage: $change_percentage%" "$LINENO"

    # Debug: Save the diff output for inspection
    diff "$previous_file" "$new_file" >"$CACHE_DIR/diff_debug.txt"
    echo "$change_percentage"

    return 0
}

# Function: Check the website for changes
check_website() {
    local -n url_settings=$1
    local group=${url_settings["GROUP"]}
    local name=${url_settings["NAME"]:-${url_settings["URL"]}}
    local website_url=${url_settings["URL"]}
    local timeout=$(get_interval_in_seconds "${url_settings["TIMEOUT"]:-$TIMEOUT}")
    local timeout_duration=$(get_interval_in_seconds "${url_settings["CMD_TIMEOUT"]:-"10s"}")
    local threshold=${url_settings["THRESHOLD"]:-$THRESHOLD}
    local encoded_url=$(echo -n "$website_url" | shasum | awk '{print $1}')
    local previous_file="$CACHE_DIR/previous_content_$encoded_url.txt"
    local current_file="$CACHE_DIR/current_content_$encoded_url.txt"
    local normalized_file="$CACHE_DIR/normalized_content_$encoded_url.txt"
    local hash_file="$CACHE_DIR/hash_$encoded_url.txt"

    log_message "DEBUG" "$SYSTEM_NAME Checking URL:" "$LINENO"
    log_message "DEBUG" "Submitted URL: $website_url" "$LINENO"
    log_message "DEBUG" "Global threshold: $THRESHOLD%" "$LINENO"
    log_message "DEBUG" "Applied threshold: $threshold%" "$LINENO"

    # Fetch the current content of the website
    if ! curl -s -f --max-time "$timeout" "$website_url" >"$current_file"; then
        log_message "ERROR" "Failed to fetch: $website_url" "$LINENO"
        return 1
    fi

    # Normalize the content
    if ! normalize_content "$current_file"; then
        log_message "ERROR" "Failed to normalize content for: $website_url" "$LINENO"
        return 1
    fi
    cp "$current_file" "$normalized_file"

    # Check if normalized file is empty
    if [ ! -s "$normalized_file" ]; then
        log_message "WARN" "Normalized content for $website_url is empty. Skipping further checks." "$LINENO"
        return 1
    fi

    # Generate hash of the normalized content
    local current_hash=$(shasum -a 256 "$normalized_file" | awk '{print $1}')
    url_settings["CURRENT_HASH"]="$current_hash"

    # Check for previous hash
    if [ -f "$hash_file" ]; then
        local previous_hash=$(cat "$hash_file")
        url_settings["PREVIOUS_HASH"]="$previous_hash"

        # Compare hashes
        if [ "$current_hash" != "$previous_hash" ]; then
            if [ -f "$previous_file" ]; then
                local change_percent=$(calculate_change_percentage "$previous_file" "$normalized_file")
                url_settings["CHANGED_PERCENT"]="$change_percent"

                # Notify if changes exceed threshold
                if [[ "$change_percent" =~ ^[0-9.]+$ ]] && (($(echo "$change_percent >= $threshold" | bc -l))); then
                    local message="$SYSTEM_NAME: $name has changed by $change_percent%!"
                    log_message "WARN" "$message" "$LINENO"
                    send_pushover_notification "NoirWatch Alert" "$message" "$website_url"
                    send_desktop_notification "NoirWatch Alert" "$message"
                    updated_cmd=${url_settings["UPDATED_CMD"]}

                    # run the configured status command
                    if [[ -n "$updated_cmd" ]]; then
                        if command -v "$updated_cmd" >/dev/null 2>&1; then
                            log_message "DEBUG" "Running command: $updated_cmd" "$LINENO"

                            # Serialize the associative array into a string
                            local serialized_settings
                            for key in "${!url_settings[@]}"; do
                                serialized_settings+="$key=${url_settings[$key]};"
                            done
                            result=$(timeout "$timeout_duration" "$updated_cmd" "$serialized_settings" 2>&1)
                            exit_code=$?
                            if [[ $exit_code -ne 0 || -z "$result" ]]; then
                                log_message "ERROR" "Command $updated_cmd failed with exit code $exit_code and result: $result" "$LINENO"
                            else
                                log_message "DEBUG" "Command $updated_cmd results: $result" "$LINENO"
                            fi
                        else
                            log_message "ERROR" "Command $updated_cmd not found" "$LINENO"
                        fi
                    fi
                else
                    log_message "DEBUG" "Changes are below the threshold: ($change_percent%)" "$LINENO"
                fi
            else
                log_message "DEBUG" "No previous content found for: $name" "$LINENO"
                log_message "DEBUG" "Saving current content for future comparison." "$LINENO"
            fi
        else
            log_message "DEBUG" "No changes detected for: $name" "$LINENO"
        fi
    else
        log_message "DEBUG" "No previous hash found for: $name" "$LINENO"
        log_message "DEBUG" "Saving current content for future comparison." "$LINENO"
    fi

    # Save the current hash and normalized content if there's no change
    echo "$current_hash" >"$hash_file"
    mv "$normalized_file" "$previous_file"
    return 0
}

# ==============================
# Main Application Execution
# ==============================

# Function: Start the main process
main() {
    local repeat_count=0
    local interval=$(get_interval_in_seconds "$CHECK_INTERVAL")

    while true; do
        # Cross-platform timestamp handling
        local current_time=$(date +%s) # Unix timestamp for calculations
        local current_timestamp
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
        else
            current_timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
        fi

        log_message "DEBUG" "Current timestamp: $current_timestamp" "$LINENO"

        # Start of main application function calls

        # If the URLs come from the CLI set the group to default
        local groups=()
        if [[ ${#CLI_URLS[@]} -gt 0 ]]; then
            groups=("default")
        else
            # Get the connection groups
            groups=($(get_connection_groups "$CONFIG_FILE"))
        fi

        # Check if groups array is empty or null
        if [[ ${#groups[@]} -eq 0 ]]; then
            log_message "FATAL" "No connection groups or urls found." "$LINENO"
            exit 1
        fi

        # Process the remaining groups
        for group in "${groups[@]}"; do
            log_message "DEBUG" "Group: $group" "$LINENO"
            local urls
            if [ -n ${#CLI_URLS[@]} ] && [ ${#CLI_URLS[@]} -gt 0 ]; then
                urls=("${CLI_URLS[@]}")
            else
                urls=($(jq -r ".urls[\"$group\"] | keys | .[]" "$CONFIG_FILE"))
            fi
            for ((i = 0; i < ${#urls[@]}; i++)); do
                local -A url_result
                if [[ ${#CLI_URLS[@]} -gt 0 ]]; then
                    url_result["GROUP"]=$group
                    local prefixed_threshold=$(echo "${urls[$i]}" | awk -F'[][]' '{print $2}')
                    url_result["URL"]=$(echo "${urls[$i]}" | sed 's/^\[[0-9]*\]//')
                    url_result["THRESHOLD"]=${prefixed_threshold:-$THRESHOLD}
                else
                    get_url_settings "$group" "$i" "$CONFIG_FILE" url_result
                    url_result["GROUP"]=$group
                fi

                check_website url_result
            done
        done

        # End of main application function calls

        # Increment the repeat counter
        repeat_count=$((repeat_count + 1))
        log_message "DEBUG" "Iteration: $repeat_count" "$LINENO"

        # Check if REPEAT is set and not zero
        if [[ -z "$REPEAT" || "$REPEAT" != 0 ]] && [[ "$repeat_count" -ge "$REPEAT" ]]; then
            log_message "DEBUG" "Reached the maximum number of repetitions: $REPEAT" "$LINENO"
            break
        else
            log_message "DEBUG" "Sleeping for $CHECK_INTERVAL" "$LINENO"
            sleep "$interval"
        fi
    done
}

# Call the function to check for required dependencies
check_dependencies

# Call the function to parse cli options
parse_cli_options "$@"

# Call the main function to start the process
start_process
